# vim: ft=zsh
# Scan zshrc.d/ and functions/ for doctor annotations
# and report which features are disabled due to missing commands.
# Also report on PATH, fpath, and completion cache health.

setopt LOCAL_OPTIONS EXTENDED_GLOB
local zsh_dir="${ZDOTDIR:-$HOME/.config/zsh}"
local ostype="${OSTYPE%%[^a-zA-Z]*}"
local max_age=72000 # 20 hours in seconds

_doctor_path() {
  print -P "%B── PATH ──%b"
  local dir dupes=() seen=()
  for dir in $path; do
    if (( ${seen[(I)$dir]} )); then
      dupes+=("$dir")
    else
      seen+=("$dir")
    fi
    if [[ -d "$dir" ]]; then
      local count=$(ls -1 "$dir" 2>/dev/null | wc -l)
      print "  ${dir} (${count} entries)"
    else
      print -P "  %F{yellow}${dir} (missing)%f"
    fi
  done
  if (( ${#dupes} )); then
    print -P "  %F{yellow}Duplicates: ${(j:, :)dupes}%f"
  fi
}

_doctor_fpath() {
  print -P "\n%B── fpath ──%b"
  local dir count total=0 dupes=() seen=()
  for dir in $fpath; do
    if (( ${seen[(I)$dir]} )); then
      dupes+=("$dir")
    else
      seen+=("$dir")
    fi
    if [[ -d "$dir" ]]; then
      count=$(ls -1 "$dir"/_*(N) 2>/dev/null | wc -l)
      (( total += count ))
      (( count > 0 )) && print "  ${dir} (${count} completions)"
    else
      print -P "  %F{yellow}${dir} (missing)%f"
    fi
  done
  print "  Total: ${total} completion functions"
  if (( ${#dupes} )); then
    print -P "  %F{yellow}Duplicates: ${(j:, :)dupes}%f"
  fi
}


_doctor_functions() {
  local dir=$1
  local -a files
  local f line desc cmds cmd missing has_annotation
  for f in "$dir"/*~*.zwc(N.); do
    files+=("$f")
  done
  (( ${#files} )) || return
  for f in "${files[@]}"; do
    has_annotation=0
    while IFS= read -r line; do
      if [[ "$line" =~ '#[[:space:]]*doctor:[[:space:]]*(.+)[[:space:]]+requires:[[:space:]]*(.+)' ]]; then
        desc="${match[1]%%[[:space:]]requires:*}"
        cmds="${match[2]}"
        missing=()
        for cmd in ${(z)cmds}; do
          (( $+commands[$cmd] )) || missing+=("$cmd")
        done
        if (( ${#missing} )); then
          print -P "  %F{yellow}⚠%f  ${f:t} (missing: ${(j:, :)missing})"
        else
          print -P "  %F{green}✓%f  ${f:t}"
        fi
        has_annotation=1
        break
      fi
    done < "$f"
    (( has_annotation )) || print -P "  %F{8}·%f  ${f:t}"
  done
}

_doctor_completions() {
  print -P "\n%B── completions ──%b"

  local dump="$zsh_dir/.zcompdump"
  if [[ -f "$dump" ]]; then
    local dump_age=$(( EPOCHSECONDS - $(stat -c %Y "$dump" 2>/dev/null || stat -f %m "$dump" 2>/dev/null) ))
    local dump_hours=$(printf '%.1f' $(( dump_age / 3600.0 )))
    local dump_stale
    if (( dump_age > max_age )); then
      dump_stale="%F{yellow}stale, will rebuild next shell%f"
    else
      dump_stale="%F{green}fresh%f"
    fi
    print -P "  .zcompdump: ${dump_hours}h old — ${dump_stale}"
    [[ -f "${dump}.zwc" ]] && print -P "  .zcompdump.zwc: compiled ✓" \
                           || print -P "  .zcompdump.zwc: %F{yellow}missing%f"
  else
    print -P "  .zcompdump: %F{yellow}missing, will be created next shell%f"
  fi

  local comp_dir="$zsh_dir/.completions"
  local cmd comp_file header file_age hours cached_ver current_ver comp_status
  for cmd in ${(k)_lazy_comp_gen}; do
    comp_file="$comp_dir/_${cmd}"
    if [[ ! -f "$comp_file" ]]; then
      print -P "  _${cmd}: %F{yellow}not cached, will generate on first use%f"
      continue
    fi

    file_age=$(( EPOCHSECONDS - $(stat -c %Y "$comp_file" 2>/dev/null || stat -f %m "$comp_file" 2>/dev/null) ))
    hours=$(printf '%.1f' $(( file_age / 3600.0 )))

    read -r header < "$comp_file"
    if [[ $header == '# lazy-completion: version='* ]]; then
      cached_ver="${header#\# lazy-completion: version=}"
      current_ver="$(eval ${_lazy_comp_ver[$cmd]} 2>/dev/null)"
      if (( file_age > max_age )) && [[ "$cached_ver" != "$current_ver" ]]; then
        comp_status="%F{yellow}stale — cached: ${cached_ver}, current: ${current_ver}%f"
      elif (( file_age > max_age )); then
        comp_status="%F{green}age check pending, version matches%f"
      else
        comp_status="%F{green}fresh%f"
      fi
      print -P "  _${cmd}: ${hours}h old — ${comp_status}"
    else
      print -P "  _${cmd}: ${hours}h old — not managed by lazy-completion"
    fi
  done
}

_doctor_plugins() {
  print -P "\n%B── plugins ──%b"
  local p
  for p in $zsh_loaded_plugins; do
    print "  $p"
  done
  if (( ${#zsh_loaded_snippets} )); then
    print -P "\n%B── snippets ──%b"
    for p in $zsh_loaded_snippets; do
      print "  $p"
    done
  fi
  if [[ -v _plugin_skipped ]] && (( ${#_plugin_skipped} )); then
    print -P "\n%B── skipped plugins ──%b"
    for p in ${(ko)_plugin_skipped}; do
      print -P "  %F{yellow}⚠%f  $p (missing: ${_plugin_skipped[$p]})"
    done
  fi
}

_doctor_compiled() {
  local -a dirs=("$zsh_dir/functions" "$zsh_dir/functions/internal")
  [[ -d "$zsh_dir/functions/$ostype" ]] && dirs+=("$zsh_dir/functions/$ostype")
  [[ -d "$zsh_dir/functions/local" ]] && dirs+=("$zsh_dir/functions/local")

  local -a stale missing
  local dir f
  for dir in "${dirs[@]}"; do
    for f in "$dir"/*(N.); do
      [[ "$f" == *.zwc ]] && continue
      if [[ ! -f "$f.zwc" ]]; then
        missing+=("${f#$zsh_dir/}")
      elif [[ "$f" -nt "$f.zwc" ]]; then
        stale+=("${f#$zsh_dir/}")
      fi
    done
  done

  print -P "\n%B── compiled functions ──%b"
  if (( ${#missing} + ${#stale} == 0 )); then
    print -P "  %F{green}✓%f  All functions compiled and up to date"
  else
    for f in $missing; do
      print -P "  %F{yellow}⚠%f  $f — not compiled"
    done
    for f in $stale; do
      print -P "  %F{yellow}⚠%f  $f — .zwc outdated"
    done
  fi
}

_doctor_path
_doctor_fpath
_doctor_plugins
_doctor_compiled
_doctor_completions

print -P "\n%B── package managers ──%b"
local pm
for pm in $_package_manager_cmds; do
  if (( $+commands[$pm] )); then
    print -P "  %F{green}✓%f  $pm"
  else
    print -P "  %F{yellow}⚠%f  $pm (missing)"
  fi
done
print -P "\n%B── aliases ──%b"
local name
for name in ${(ko)_alias_if_cmds}; do
  local alias_val=${_alias_if_cmds[$name]}
  local alias_cmd=${alias_val%% *}
  if (( $+commands[$alias_cmd] )); then
    print -P "  %F{green}✓%f  $name → $alias_val"
  else
    print -P "  %F{yellow}⚠%f  $name (missing: $alias_cmd)"
  fi
done
print -P "\n%B── direnv ──%b"
if (( $+commands[direnv] )); then
  print -P "  %F{green}✓%f  direnv hook"
else
  print -P "  %F{yellow}⚠%f  direnv hook (missing: direnv)"
fi
print -P "\n%B── lazy completions ──%b"
for cmd in ${(ko)_lazy_comp_gen}; do
  if (( $+commands[$cmd] )); then
    print -P "  %F{green}✓%f  $cmd"
  else
    print -P "  %F{yellow}⚠%f  $cmd (missing)"
  fi
done
print -P "\n%B── functions ──%b"
_doctor_functions "$zsh_dir/functions"

# OS-specific: env/<ostype> + functions/<ostype>/
print -P "\n%B── OS: $ostype ──%b"
print -P "  %Benv/$ostype%b"
if [[ -f "$zsh_dir/env/$ostype" ]]; then
  print -P "  %F{green}✓%f  loaded"
else
  print -P "  %F{8}·%f  not present"
fi
print -P "  %Bfunctions/$ostype/%b"
_doctor_functions "$zsh_dir/functions/$ostype"

# Local: env/local + functions/local/
print -P "\n%B── local ──%b"
print -P "  %Benv/local%b"
if [[ -f "$zsh_dir/env/local" ]]; then
  print -P "  %F{green}✓%f  loaded"
else
  print -P "  %F{8}·%f  not present"
fi
print -P "  %Bfunctions/local/%b"
_doctor_functions "$zsh_dir/functions/local"

unfunction _doctor_plugins _doctor_path _doctor_fpath _doctor_functions _doctor_compiled _doctor_completions
